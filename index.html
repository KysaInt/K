<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AYE'BABYLON</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: linear-gradient(0deg, #000000, #1a1a1a); /* 初始渐变色 */
            animation: gradientAnimation 10s infinite alternate; /* 添加动画 */
        }

        @keyframes gradientAnimation {
            0% {
                background: linear-gradient(0deg, #000000, #1a1a1a);
            }
            50% {
                background: linear-gradient(0deg, #1a1a1a, #333333);
            }
            100% {
                background: linear-gradient(0deg, #333333, #000000);
            }
        }

        canvas {
            display: block;
        }

        #fixedText {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 24px;
            font-weight: 100;
            font-family: "Arial", sans-serif;
            color: white;
            z-index: 100;
            pointer-events: none;
        }

        #loudnessDisplay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 18px;
            font-family: "Arial", sans-serif;
            color: white;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="fixedText">AYE-2025/04</div>
    <div id="loudnessDisplay">Loudness: 0</div>
    <canvas id="renderCanvas" touch-action="none" style="width: 100%; height: 100%;"></canvas>

    <!-- 添加背景音乐 -->
    <audio id="backgroundMusic" preload="auto" loop>
        <source src="./audio/bg.ogg" type="audio/ogg"> <!-- 修正路径 -->
        <source src="./audio/bg.mp3" type="audio/mpeg"> <!-- 修正路径 -->
        您的浏览器不支持音频播放。
    </audio>

    <!-- 引入 Babylon.js 和加载器 -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <!-- Babylon.js 脚本 -->
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const backgroundMusic = document.getElementById("backgroundMusic");
        const loudnessDisplay = document.getElementById("loudnessDisplay");

        // 创建音频上下文和分析器
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioSource = audioContext.createMediaElementSource(backgroundMusic);
        const analyser = audioContext.createAnalyser();
        audioSource.connect(analyser);
        analyser.connect(audioContext.destination);
        analyser.fftSize = 256;

        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);

            // 设置背景颜色为纯黑
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

            // 添加辉光层
            const glowLayer = new BABYLON.GlowLayer("glow", scene);
            glowLayer.intensity = 0.7; // 将辉光强度上限降低至 0.7

            // 添加相机并顺时针旋转 180°
            const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI, -Math.PI, 8, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            // 加载 3D 模型
            BABYLON.SceneLoader.Append("models/", "model.glb", scene, function () {
                console.log("模型加载完成！");

                scene.meshes.forEach((mesh) => {`
                    if (mesh.material) {
                        // 初始材质为白色
                        const pbrMaterial = new BABYLON.PBRMaterial("pbr", scene);
                        pbrMaterial.albedoColor = new BABYLON.Color3(1, 1, 1); // 白色
                        pbrMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1); // 白色
                        mesh.material = pbrMaterial;

                        // 将物体添加到辉光层
                        glowLayer.addIncludedOnlyMesh(mesh);

                        // 默认旋转 180 度
                        mesh.rotation.y += Math.PI;

                        // 添加循环彩色变化动画
                        const colorAnimation = new BABYLON.Animation(
                            "colorAnimation",
                            "material.albedoColor",
                            30,
                            BABYLON.Animation.ANIMATIONTYPE_COLOR3,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                        );

                        const colorKeys = [
                            { frame: 0, value: new BABYLON.Color3(1, 1, 1) }, // 初始白色
                            { frame: 75, value: new BABYLON.Color3(Math.random(), Math.random(), Math.random()) }, // 随机彩色
                            { frame: 150, value: new BABYLON.Color3(Math.random(), Math.random(), Math.random()) }, // 随机彩色
                            { frame: 225, value: new BABYLON.Color3(Math.random(), Math.random(), Math.random()) }, // 随机彩色
                            { frame: 300, value: new BABYLON.Color3(1, 1, 1) } // 结束白色
                        ];

                        colorAnimation.setKeys(colorKeys);
                        mesh.animations.push(colorAnimation);
                        scene.beginAnimation(mesh, 0, 300, true);
                    }
                });
            });

            return scene;
        };

        const scene = createScene();

        const startAudioAndAnimations = () => {
            // 播放背景音乐
            if (backgroundMusic.paused) {
                backgroundMusic.volume = 0.5;
                backgroundMusic.play().then(() => {
                    console.log("背景音乐播放成功");
                }).catch(error => {
                    console.error("背景音乐播放失败:", error);
                    alert("无法播放背景音乐，请检查音频文件路径或浏览器设置。");
                });
            }

            // 启动动画并缓慢变为彩色
            scene.meshes.forEach(mesh => {
                const floatAnimation = new BABYLON.Animation(
                    "floatAnimation",
                    "position.y",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                const floatKeys = [
                    { frame: 0, value: mesh.position.y },
                    { frame: 150, value: mesh.position.y + 0.5 },
                    { frame: 300, value: mesh.position.y }
                ];
                floatAnimation.setKeys(floatKeys);
                mesh.animations.push(floatAnimation);

                const rotateAnimation = new BABYLON.Animation(
                    "rotateAnimation",
                    "rotation.y",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                const rotateKeys = [
                    { frame: 0, value: mesh.rotation.y },
                    { frame: 300, value: mesh.rotation.y + Math.PI * 2 }
                ];
                rotateAnimation.setKeys(rotateKeys);
                mesh.animations.push(rotateAnimation);

                const randomRotationAnimation = new BABYLON.Animation(
                    "randomRotationAnimation",
                    "rotation",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );

                const easingFunction = new BABYLON.SineEase();
                easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);

                const randomRotationKeys = [
                    { frame: 0, value: mesh.rotation.clone() },
                    { frame: 60, value: new BABYLON.Vector3(
                        mesh.rotation.x + Math.random() * Math.PI,
                        mesh.rotation.y + Math.random() * Math.PI,
                        mesh.rotation.z + Math.random() * Math.PI
                    ) },
                    { frame: 120, value: new BABYLON.Vector3(
                        mesh.rotation.x + Math.random() * Math.PI,
                        mesh.rotation.y + Math.random() * Math.PI,
                        mesh.rotation.z + Math.random() * Math.PI
                    ) },
                    { frame: 180, value: new BABYLON.Vector3(
                        mesh.rotation.x + Math.random() * Math.PI,
                        mesh.rotation.y + Math.random() * Math.PI,
                        mesh.rotation.z + Math.random() * Math.PI
                    ) },
                    { frame: 240, value: new BABYLON.Vector3(
                        mesh.rotation.x + Math.random() * Math.PI,
                        mesh.rotation.y + Math.random() * Math.PI,
                        mesh.rotation.z + Math.random() * Math.PI
                    ) },
                    { frame: 300, value: mesh.rotation.clone() }
                ];

                randomRotationAnimation.setKeys(randomRotationKeys);
                randomRotationAnimation.setEasingFunction(easingFunction);
                mesh.animations.push(randomRotationAnimation);

                scene.beginAnimation(mesh, 0, 300, true, 0.6);
            });
        };

        // 确保用户交互触发背景音乐播放
        document.body.addEventListener("click", startAudioAndAnimations, { once: true });

        engine.runRenderLoop(() => {
            // 响度控制逻辑
            analyser.getByteFrequencyData(dataArray);
            const averageLoudness = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;

            // 更新屏幕左下角的响度显示
            loudnessDisplay.textContent = `Loudness: ${averageLoudness.toFixed(2)}`;

            // 根据响度动态调整模型材质的亮度和缩放
            scene.meshes.forEach(mesh => {
                if (mesh.material && mesh.material.emissiveColor) {
                    const intensity = averageLoudness / 256; // 归一化响度值
                    mesh.material.emissiveColor = mesh.material.albedoColor.scale(intensity); // 调整发光颜色

                    // 动态调整缩放，整体缩放范围扩大 3 倍
                    const scaleFactor = (1 + intensity * 2) * 3; // 缩放范围 [3, 9]
                    mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);
                }
            });

            scene.render();
        });

        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>