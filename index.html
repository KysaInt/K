<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AYE'babylon</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Á¶ÅÁî®ÊªöÂä® */
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body style="background-color: black;"> <!-- ËÆæÁΩÆÂàùÂßãËÉåÊôØ‰∏∫ÈªëËâ≤ -->
    <canvas id="renderCanvas" style="width: 100vw; height: 100vh;"></canvas>
    <audio id="backgroundMusic" src="./audio/bg.mp3" loop></audio> <!-- ‰øÆÊîπËÉåÊôØÈü≥‰πê -->
    <div id="progressContainer" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 20px; font-family: 'Arial', sans-serif; z-index: 1; display: flex; align-items: center;">
        <span>AYE</span>
        <div id="progressBar" style="width: 4px; height: 20px; background-color: gray; margin: 0 10px; position: relative; overflow: hidden;">
            <div id="progressFill" style="width: 100%; height: 0%; background-color: white; position: absolute; bottom: 0; transition: height 0.1s;"></div>
        </div>
        <span>2025/04</span>
    </div>
    <div id="touchToPlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 72px; font-family: 'Arial', sans-serif; z-index: 2;">
        Touch&Play
    </div>
    <button id="muteButton" style="position: absolute; bottom: 20px; right: 20px; z-index: 3; background-color: rgba(0, 0, 0, 0.5); color: white; border: none; border-radius: 50%; padding: 10px; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center;">
        üîä
    </button>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);

            // Âà†Èô§Âü∫Á°ÄÁÅØÂÖâ
            // ËÆæÁΩÆËÉåÊôØÈ¢úËâ≤‰∏∫Á∫ØÈªë
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

            // Ê∑ªÂä†ËæâÂÖâÊïàÊûú
            const glowLayer = new BABYLON.GlowLayer("glow", scene);
            glowLayer.intensity = .4;

            // Ê∑ªÂä†Áõ∏Êú∫Âπ∂Á°Æ‰øùÁõÆÊ†áÂ±Ö‰∏≠
            const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI, Math.PI, 1.8, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            // Á¶ÅÁî®ÊªöËΩÆÁº©ÊîæÂäüËÉΩ
            camera.inputs.removeByType("ArcRotateCameraMouseWheelInput");

            // Ê†πÊçÆËßÜÂè£ÈïøÂÆΩÊØîË∞ÉÊï¥Áõ∏Êú∫ËßíÂ∫¶
            const adjustCameraAngle = () => {
                const aspectRatio = window.innerWidth / window.innerHeight;
                if (aspectRatio > 1) {
                    // ÂÆΩÂ±èÊ®°Âºè
                    camera.alpha = Math.PI / -2; // Ê∞¥Âπ≥ÊñπÂêë
                    camera.beta = Math.PI ;  // ‰øØËßÜËßíÂ∫¶
                } else {
                    // Á´ñÂ±èÊ®°Âºè
                    camera.alpha = Math.PI;     // ÂûÇÁõ¥ÊñπÂêë
                    camera.beta = Math.PI ;  // ÂûÇÁõ¥‰øØËßÜ
                }
            };

            // ÂàùÂßãÂåñÁõ∏Êú∫ËßíÂ∫¶
            adjustCameraAngle();

            // ÁõëÂê¨Á™óÂè£Â∞∫ÂØ∏ÂèòÂåñË∞ÉÊï¥Áõ∏Êú∫ËßíÂ∫¶
            window.addEventListener("resize", adjustCameraAngle);

            // Á°Æ‰øùÁõ∏Êú∫ÁöÑËßÜËßíÈÄÇÈÖçÂ±èÂπïÊØî‰æã
            camera.viewport = new BABYLON.Viewport(0, 0, 1, 1);

            // Âä†ËΩΩ .glb Ê®°Âûã
            BABYLON.SceneLoader.Append("models/", "model.glb", scene, function () {
                console.log("Ê®°ÂûãÂä†ËΩΩÂÆåÊàêÔºÅ");

                const numMeshes = scene.meshes.length; // Ëé∑ÂèñÁΩëÊ†ºÊï∞Èáè
                const frequencyStep = Math.floor(dataArray.length / numMeshes); // ÊØè‰∏™ÁΩëÊ†ºÂØπÂ∫îÁöÑÈ¢ëÁéáÂå∫Èó¥Â§ßÂ∞è

                scene.meshes.forEach((mesh, index) => {
                    // ËÆæÁΩÆÂàùÂßãÊùêË¥®‰∏∫ÁôΩËâ≤ÔºåÂèëÂÖâÂº∫Â∫¶‰∏∫ 1
                    const material = new BABYLON.PBRMaterial(`pbr_${index}`, scene);
                    material.albedoColor = new BABYLON.Color3(1, 1, 1); // ÁôΩËâ≤
                    material.emissiveColor = new BABYLON.Color3(1, 1, 1); // ÁôΩËâ≤ÂèëÂÖâ
                    material.emissiveIntensity = 1; // ÂàùÂßãÂèëÂÖâÂº∫Â∫¶‰∏∫ 1
                    material.metallic = 0.5;
                    material.roughness = 0.2;

                    // Ê∑ªÂä†Ëè≤Ê∂ÖÂ∞îÂèçÂ∞ÑË¥¥Âõæ
                    const fresnelTexture = new BABYLON.FresnelParameters();
                    fresnelTexture.bias = 0.1;
                    fresnelTexture.power = 2;
                    fresnelTexture.leftColor = new BABYLON.Color3(1, 1, 1); // ÁôΩËâ≤
                    fresnelTexture.rightColor = new BABYLON.Color3(0, 0, 0); // ÈªëËâ≤
                    material.reflectionFresnelParameters = fresnelTexture;

                    mesh.material = material;

                    // ÂÆö‰πâÂä®ÊÄÅÈöèÊú∫Ê∏êÂèòÂΩ©Ëâ≤Âæ™ÁéØÂä®Áîª
                    const colorAnimation = new BABYLON.Animation(
                        `colorAnimation_${index}`,
                        "material.emissiveColor",
                        15,
                        BABYLON.Animation.ANIMATIONTYPE_COLOR3,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                    );

                    const randomColor1 = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                    const randomColor2 = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                    const randomColor3 = new BABYLON.Color3(Math.random(), Math.random(), Math.random());

                    const colorKeyFrames = [
                        { frame: 0, value: randomColor1 }, // ÈöèÊú∫ÂΩ©Ëâ≤ 1
                        { frame: 100, value: randomColor2 }, // ÈöèÊú∫ÂΩ©Ëâ≤ 2
                        { frame: 200, value: randomColor3 }, // ÈöèÊú∫ÂΩ©Ëâ≤ 3
                        { frame: 300, value: randomColor1 } // ÂõûÂà∞ÈöèÊú∫ÂΩ©Ëâ≤ 1
                    ];

                    colorAnimation.setKeys(colorKeyFrames);
                    mesh.animations.push(colorAnimation);

                    // ÂºÄÂßãÊí≠ÊîæÊùêË¥®È¢úËâ≤Âä®Áîª
                    scene.beginAnimation(mesh, 0, 300, true);

                    // ÂÆö‰πâ 10 ÁªÑ‰∏çÂêåÁöÑÊóãËΩ¨Âä®ÁîªÂÖ≥ÈîÆÂ∏ß
                    const rotationKeyFramesGroups = Array.from({ length: 10 }, () => [
                        { frame: 0, value: new BABYLON.Vector3(0, 0, 0) },
                        { frame: 25, value: new BABYLON.Vector3(0, 0, 0) }, // Ëµ∑ÁÇπÈùôÊ≠¢Êó∂Èó¥Áº©Áü≠‰∏ÄÂçä
                        { frame: 150, value: new BABYLON.Vector3(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI) },
                        { frame: 275, value: new BABYLON.Vector3(0, 0, 0) }, // ÁªàÁÇπÈùôÊ≠¢Êó∂Èó¥Áº©Áü≠‰∏ÄÂçä
                        { frame: 300, value: new BABYLON.Vector3(0, 0, 0) }
                    ]);

                    // ÂàõÂª∫ÊóãËΩ¨Âä®Áîª
                    const rotationAnimation = new BABYLON.Animation(
                        `rotationAnimation_${index}`,
                        "rotation",
                        15, // Âä®ÁîªÈÄüÁéá
                        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT // ‰∏çÂæ™ÁéØÔºåÁ≠âÂæÖÈáçÊñ∞ÈÄâÊã©Âä®Áîª
                    );

                    // ËÆæÁΩÆÁºìÂä®ÂáΩÊï∞
                    const easingFunction = new BABYLON.QuadraticEase(); // ‰ΩøÁî®‰∫åÊ¨°ÁºìÂä®ÂáΩÊï∞
                    easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
                    rotationAnimation.setEasingFunction(easingFunction);

                    // ÈöèÊú∫Êí≠ÊîæÂä®Áîª
                    const playRandomAnimation = () => {
                        const randomGroup = Math.floor(Math.random() * 10); // ÈöèÊú∫ÈÄâÊã© 0 Âà∞ 9
                        rotationAnimation.setKeys(rotationKeyFramesGroups[randomGroup]);

                        mesh.animations = [rotationAnimation];
                        scene.beginAnimation(mesh, 0, 300, false, 1, () => {
                            playRandomAnimation(); // Âä®ÁîªÊí≠ÊîæÂÆåÊØïÂêéÈáçÊñ∞ÈÄâÊã©ÈöèÊú∫Âä®Áîª
                        });
                    };

                    playRandomAnimation(); // ÂºÄÂßãÊí≠ÊîæÈöèÊú∫Âä®Áîª

                    // Ê∑ªÂä†ÈöèÊú∫ÊµÆÂä®Âä®Áîª
                    const floatAnimation = new BABYLON.Animation(
                        `floatAnimation_${index}`,
                        "position.y",
                        15, // Âä®ÁîªÈÄüÁéá‰∏éÊóãËΩ¨Âä®Áîª‰∏ÄËá¥
                        BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                    );

                    // ËÆæÁΩÆÊµÆÂä®Âä®ÁîªÂÖ≥ÈîÆÂ∏ß
                    const floatKeyFrames = [
                        { frame: 0, value: mesh.position.y },
                        { frame: 100, value: mesh.position.y + Math.random() * 0.5 },
                        { frame: 200, value: mesh.position.y - Math.random() * 0.5 },
                        { frame: 300, value: mesh.position.y }
                    ];

                    floatAnimation.setKeys(floatKeyFrames);

                    // ËÆæÁΩÆÁºìÂä®ÂáΩÊï∞
                    const floatEasingFunction = new BABYLON.SineEase();
                    floatEasingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
                    floatAnimation.setEasingFunction(floatEasingFunction);

                    mesh.animations.push(floatAnimation);
                    scene.beginAnimation(mesh, 0, 300, true);

                    // ÁªëÂÆöÈ¢ëÁéáÂå∫Èó¥ÁöÑÂìçÂ∫¶ÂÄºÂà∞ÂèëÂÖâÂº∫Â∫¶
                    mesh.updateEmissiveIntensity = () => {
                        const start = index * frequencyStep;
                        const end = start + frequencyStep;
                        const averageLoudness = dataArray.slice(start, end).reduce((sum, value) => sum + value, 0) / frequencyStep;
                        material.emissiveIntensity = (averageLoudness / 256) * 2; // Áõ¥Êé•ÁªëÂÆöÂà∞ÂìçÂ∫¶ÂΩ±Âìç
                    };
                });
            });

            return scene;
        };

        const scene = createScene();

        // Á°Æ‰øù canvas Â°´ÂÖÖÊï¥‰∏™Â±èÂπï
        const resizeCanvas = () => {
            canvas.style.width = "100vw";
            canvas.style.height = "100vh";
            engine.resize();
        };

        // ÁõëÂê¨Á™óÂè£Â∞∫ÂØ∏ÂèòÂåñ
        window.addEventListener("resize", resizeCanvas);

        // ÂàùÂßãÂåñÊó∂Ë∞ÉÊï¥ canvas Â∞∫ÂØ∏
        resizeCanvas();

        const backgroundMusic = document.getElementById("backgroundMusic");
        backgroundMusic.volume = 0.5;

        // ÈùôÈü≥ÊåâÈíÆÈÄªËæë
        const muteButton = document.getElementById("muteButton");
        let isMuted = false;

        muteButton.addEventListener("click", () => {
            isMuted = !isMuted;
            backgroundMusic.muted = isMuted;
            muteButton.textContent = isMuted ? "üîá" : "üîä"; // ‰ΩøÁî® Unicode ÂõæÊ†áÂàáÊç¢
        });

        // ÂàõÂª∫Èü≥È¢ë‰∏ä‰∏ãÊñáÂíåÂàÜÊûêÂô®
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioSource = audioContext.createMediaElementSource(backgroundMusic);
        const analyser = audioContext.createAnalyser();
        audioSource.connect(analyser);
        analyser.connect(audioContext.destination);
        analyser.fftSize = 256;

        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        const progressFill = document.getElementById("progressFill");
        const touchToPlay = document.getElementById("touchToPlay");

        const startInteraction = () => {
            // ÈöêËóè "Touch&Play"
            touchToPlay.style.display = "none";

            // ÊÅ¢Â§çÈü≥È¢ë‰∏ä‰∏ãÊñá
            if (audioContext.state === "suspended") {
                audioContext.resume();
            }
            backgroundMusic.play();

            // ÁßªÈô§ÂàùÂßãÈªëËâ≤ËÉåÊôØ
            document.body.style.backgroundColor = "transparent";

            engine.runRenderLoop(() => {
                // Ëé∑ÂèñÈü≥È¢ëÊï∞ÊçÆ
                analyser.getByteFrequencyData(dataArray);

                // Êõ¥Êñ∞ÊØè‰∏™ÁΩëÊ†ºÁöÑÂèëÂÖâÂº∫Â∫¶
                scene.meshes.forEach(mesh => {
                    if (mesh.updateEmissiveIntensity) {
                        mesh.updateEmissiveIntensity();
                    }
                });

                // Êõ¥Êñ∞ËøõÂ∫¶Êù°È´òÂ∫¶
                const averageLoudness = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
                const progressPercentage = (averageLoudness / 256) * 100;
                progressFill.style.height = `${progressPercentage}%`;

                // Ê†πÊçÆÂìçÂ∫¶Âä®ÊÄÅË∞ÉÊï¥Ê®°ÂûãÁöÑÊï¥‰ΩìÁº©Êîæ
                scene.meshes.forEach(mesh => {
                    const scaleFactor = 1 + averageLoudness / 256; // ÂìçÂ∫¶ÂΩí‰∏ÄÂåñÂπ∂ÁªëÂÆöÂà∞Áº©Êîæ
                    mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);
                });

                scene.render();
            });
        };

        // Á≠âÂæÖÁî®Êà∑‰∫§‰∫íÂêéÂêØÂä®
        window.addEventListener("click", startInteraction, { once: true });
        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>
